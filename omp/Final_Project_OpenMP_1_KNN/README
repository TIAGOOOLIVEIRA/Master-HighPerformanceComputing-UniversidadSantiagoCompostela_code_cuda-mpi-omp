After running the sequential implementation of the knn code and running gprof to profile the code, 
the report shows that calculate_test is a wrapper for calculate_distance_test, contributing 0.18% self-time but driving calls to calculate_distance_test.

So I decided to parallelize the calculate_test function, which is the main function that calls the calculate_distance_test function.

After running the parallel implementation of the knn code and running gprof to profile the code again, some improvements were observed in the profile report. 
Also the execution time was reduced: from 46s to 32s (average). Bear in mind that the 8 threads were used in the parallel implementation (OMP_NUM_THREADS=8).

Then I decided to also parallelize the calculate_distance_test function , which is the main function that calls the calculate_error function.
It was possible to eliminate one for loop, so the execution time was reduced: from 32s to 28s (average).

Finally, I decided to parallelize the calculate_error function, which is the main function that calls the calculate_distance_test function and also contributes with 28% of total time - as the gprof statistics shows.
With this last parallelization, the execution time was reduced: from 28s to 12s (average).

Time execution for KNN sequential
gcc -o knn knn.c -lm -pg -O2 -g
gprof knn gmon.out > profile_sequential.txt
[TL;DR]Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ns/call  ns/call  name    
 43.51     19.41    19.41 22227777   873.39   873.39  calculate_distance_test
 33.24     34.25    14.83                             __gmon_start__
 16.56     41.64     7.39                             calculate_error
  6.63     44.59     2.96                             merge
  0.18     44.67     0.08                             calculate_test

Time Execution
real	0m46.293s
user	0m45.929s
sys	0m0.247s

real	0m46.092s
user	0m45.679s
sys	0m0.295s

real	0m46.443s
user	0m46.028s
sys	0m0.303s



export OMP_NUM_THREADS=8

Time execution for KNN with parallelism in loops (calculate_test) function
gcc -o knn knn_omp.c -lm -pg -O2 -g -fopenmp
gprof knn gmon.out > profile_calculate_test.txt
[TL;DR]Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  Ts/call  Ts/call  name    
 45.32     20.70    20.70                             calculate_distance_test
 32.40     35.51    14.80                             __gmon_start__
 16.15     42.88     7.38                             calculate_error
  6.24     45.73     2.85                             merge

Time Execution
real	0m32.295s
user	0m49.355s
sys	0m0.206s

real	0m32.394s
user	0m49.586s
sys	0m0.216s

real	0m32.468s
user	0m49.803s
sys	0m0.239s

Time execution for KNN with parallelism in loops (calculate_test + calculate_distance_test)
gcc -o knn knn_omp.c -lm -pg -O2 -g -fopenmp
gprof knn gmon.out > profile_calculate_test__calculate_distance_test.txt
[TL;DR]Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  Ts/call  Ts/call  name    
 56.63     14.79    14.79                             __gmon_start__
 28.30     22.17     7.39                             calculate_error
 10.74     24.98     2.80                             merge
  4.37     26.12     1.14                             calculate_distance_test
  0.08     26.14     0.02                             calculate_distance_test_old

Time Execution
real	0m28.757s
user	0m35.249s
sys	0m0.245s

real	0m28.745s
user	0m35.138s
sys	0m0.251s

real	0m29.047s
user	0m36.002s
sys	0m0.265s

Time execution for KNN with parallelism in loops (calculate_test + calculate_distance_test + calculate_error)
gcc -o knn knn_omp.c -lm -pg -O2 -g -fopenmp
gprof knn gmon.out > profile_calculate_test__calculate_distance_test__calculate_error.txt
[TL;DR]Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  Ts/call  Ts/call  name    
 84.10     22.92    22.92                             __gmon_start__
 10.78     25.85     2.94                             merge
  5.18     27.27     1.41                             calculate_distance_test

Time Execution
real	0m12.171s
user	0m35.817s
sys	0m0.210s

real	0m12.127s
user	0m35.844s
sys	0m0.218s

real	0m12.224s
user	0m35.987s
sys	0m0.2


Optimization by leveraging GCC flags
The performance did not improve significantly, but the vectorization was enabled.
Also it is possible to spot the usage of 512-bit SIMD operations (fully utilizing AVX-512 capabilities) for the "64 byte vectors".

gcc -o knn knn_omp.c -lm -pg -O2 -g -fopenmp -fno-trapping-math -mtune=native -march=native -fno-math-errno -fstrict-aliasing -mprefer-vector-width=512 -fopt-info-vec-missed -fopt-info-vec=vec_report.txt

cat vec_report.txt
knn.c:224:13: optimized: loop vectorized using 16 byte vectors
knn.c:226:15: optimized: loop vectorized using 16 byte vectors
knn.c:224:13: optimized: loop vectorized using 16 byte vectors
knn.c:226:15: optimized: loop vectorized using 16 byte vectors
knn.c:224:13: optimized: loop vectorized using 16 byte vectors
knn.c:226:15: optimized: loop vectorized using 16 byte vectors
knn.c:224:13: optimized: loop vectorized using 16 byte vectors
knn.c:226:15: optimized: loop vectorized using 16 byte vectors
knn.c:224:13: optimized: loop vectorized using 16 byte vectors
knn.c:226:15: optimized: loop vectorized using 16 byte vectors
knn.c:224:13: optimized: loop vectorized using 16 byte vectors
knn.c:226:15: optimized: loop vectorized using 16 byte vectors
knn.c:224:13: optimized: loop vectorized using 64 byte vectors
knn.c:224:13: optimized: loop vectorized using 32 byte vectors
knn.c:226:15: optimized: loop vectorized using 64 byte vectors
knn.c:224:13: optimized: loop vectorized using 64 byte vectors
knn.c:224:13: optimized: loop vectorized using 32 byte vectors
knn.c:226:15: optimized: loop vectorized using 64 byte vectors
knn.c:224:13: optimized: loop vectorized using 64 byte vectors
knn.c:224:13: optimized: loop vectorized using 32 byte vectors
knn.c:226:15: optimized: loop vectorized using 64 byte vectors
knn.c:224:13: optimized: loop vectorized using 64 byte vectors
knn.c:224:13: optimized: loop vectorized using 32 byte vectors
knn.c:226:15: optimized: loop vectorized using 64 byte vectors


Time Execution for GCC flags
real	0m12.327s
user	0m36.229s
sys	0m0.239s

real	0m12.316s
user	0m36.442s
sys	0m0.220s

real	0m12.204s
user	0m36.003s
sys	0m0.199s


Next steps:
- Improve data alignment and memory access patterns
- Validate the actual usage of AVX-512 instructions by inspecting the generated assembly code
- Try to install likwid and use it to profile the code in the FT3 cluster.